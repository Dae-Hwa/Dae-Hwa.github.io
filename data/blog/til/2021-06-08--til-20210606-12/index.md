---
title: TIL-20210606~12
createdDate: "2021-06-08 10:11:44"
updatedDate: "2021-06-08 10:11:44"
author: 정대화
tags:
  - til
draft: false
---

## TODO

- [ ] MockMvc 분석
- [ ] 우아한 객체지향
- [ ] 이런 REST로 괜찮은가
- 알고리즘
  - [ ] [후위표기식](https://www.acmicpc.net/problem/1918)
  - [ ] [스타트택시](https://www.acmicpc.net/problem/19238)
  - [ ] [마법사 상어와 파이어볼](https://www.acmicpc.net/problem/20056)
  - [ ] [행렬](https://www.acmicpc.net/problem/1080)

- [ ] 객체지향 정리(호눅스 과제)
- [ ] AWS 강의듣기
- [ ] 데브독스 넥스트

- [ ] 엘라스틱서치
- [ ] 서브넷 구분
- [ ] s3 이용
- [ ] 깃헙액션으로 aws 배포
- [ ] classForName 테스트

## 0606

- 객체 지향 읽을거리를 정리해봤다. 자료가 꽤 모였는데, 다음 주에는 일단 객체지향의 사실과 오해 먼저 정리를 해봐야겠다.

## 0607

- 새 프로젝트다. 이번에는 원하는만큼 할 수 있을지... 히로와 같이 팀이 되었는데 재미있을 것 같다.

- 동적 쿼리로 DB조회하는 대신, 클라이언트에서 필터를 먹이는걸 제안해주셨다. 각각 장단이 있긴 한데, 너무 당연하게 서버에서 페이징 처리를 해야 한다고 생각했다. 그런데 또 생각해보면 한 프로젝트에 속도 장애가 날 정도의 이슈가 등록이 될 것이냐? 그것도 아니다. 과연...

## 0608

- 클라이언트에서 필터 처리를 하는 것으로 결정했다. 만약 프로젝트 단위라고 생각했을 경우 속도에 지장없을 정도의 개수라고 판단했다. 문제가 있을 것 같은 부분들은 회의를 통해 해결했는데, 마지막 프로젝트여서 그런지 모두 적극적이어서 좋았다.

- API는 대충 정해졌다. 내일 빠르게 목업을 만들고 서비스 로직으로 넘어가려 한다. 내일 작업을 어떻게 진행할지 생각을 해봤는데, 내가 서버 환경 세팅을 하고 히로는 DB테스트를 해보는 식으로 분업을 해보면 될 것 같다.

## 0609

- 오늘 수업은 Loop Invariant이었다. 알고리즘에 관한 것이었는데, 선행조건과 후행조건 사이에 있는 반복조건을 제외한 로직인데, 단순히 로직 자체를 말하는 것은 아니고 공통적으로 일반화 된 공식을 말하는 것 같다. 좀 더 찾아봐야겠다.

- 목업 API를 작성했다. 다 작성하지는 않고 일부분 작성했는데, 롬복을 쓰니 확실히 속도가 빠르다. 단점은 모르는 어노테이션이 있다는 점인데, 롬복을 공부하지 않고 막 쓰니 그런 것 같다. 따로 공부를 해야할까?

## 0610

- 멀티파트는 멀티파트 객체로 받아야 한다. 바이트 배열은 바이트로 보냈을때 받는다. 폼데이터로 감싸서 바디에 전송하면 폼을 전송한것과 같이 들어온다. 리퀘스트 DTO 내부에 멀티파트와 나머지 필드를 만들어주면 된다.

- 롬복의 Value 어노테이션을 쓰면 `private final`이 묵시적으로 선언된다. 좋아보이긴 한데, VO보다는 오히려 엔티티같은 객체에 좀 더 어울리는 것이 아닌가? 하는 생각도 들었다. 그리고 모든 것을 빼도 제대로 동작하게 만들도록 하는 방어적 코드 관점에서는 별로인게 아닌가 싶다. Autowired를 지양하는 것 처럼.

- 이번 팀원들과 잘 맞아서 재밌다. 잘 생각해봐야 할 것은 내가 재밌으면 다른 사람은 재미없을 가능성이 높다는 것..ㅎㅎ.. 그래도 잃었던 리듬감을 다시 찾아오는 것 같아서 좋다.

- 오늘 히로랑 객체지향에 관한 얘기를 했다. 이후에 해본 생각들이다.

  뷰에 보내주는 DTO와 DB에 보내줄 DTO에 관한 얘기였다. 이런 객체들은 사실 객체가 아니라 자료 구조(data structure)에 가깝다는 것. class라 생각하면 struct라고 생각해볼 수 있겠다. DTO와 엔티티는 양 끝에 있는 스냅샷이다. 가운데에서 객체가 활동하다가 특정 시점의 상태를 자료구조로 변환하여 보내준다.

  그런 관점에서 보면 ORM의 의미를 보다 명확하게 알 수 있다. 엄밀히 말하면 ORM은 entiy(비즈니스 데이터)와 db 테이블을 매핑하는 것이기 때문에 객체 관게 매퍼가 아니다. 그럼에도 ORM이라 부르는 이유는 프레임워크 단에서 객체지향적인 설계를 강제해주기 때문이다. ORM은 자료구조와 테이블을 매핑해주지만, 객체지향 적인 설계를 했기 때문에 매핑의 결과로 나오는 자료구조를 객체처럼 사용할 수 있다. 반면, 스프링에는 객체지향적인 요소가 많이 들어있음에도 웹 아키텍쳐에서 사용되는 MVC의 흐름이 절차적이기 때문에 문제가 발생할 수 있다. 물론 MVC가 객체지향적이지 않다는 논거 중에 양 극단에 객체가 아닌 자료 구조가 사용되기 때문이라는 것이 가장 주요하지만, 이외에도 웹 아키텍쳐의 흐름은 절차적일 수 밖에 없다. 잘 생각해보면 이는 어쩔 수 없는 부분이다. switch문을 아무리 제거하려 해봐도 완전히 제거하는 것은 불가능한 것 처럼, 절차적인 흐름을 어디에선가는 가져가야 한다. 아무리 캡슐화시킨다 한들, 그 것은 관점의 차이일 뿐이기 때문이다. 따라서 절차적인 부분과 객체의 세계를 구현할 부분을 잘 나눠서 격리시켜야 한다. 서로 오염되지 않도록.

  MVC의 장점은 각 레이어를 고립시켜서 개발한다면 양 극단에 있는 객체지향적이지 않은 부분을 배제하고 핵심적인 부분에서 객체를 이용해 구현할 수 있다는 점이다. 하지만 이를 강제하기 전까지는 단순한 패턴에 불과하다. 스프링 MVC에서도 마찬가지로 각 영역을 구분지어주는 강제성이 없다. 이 때문에 필요에 따라 서비스를 생략하거나 각 레이어의 인터페이스를 생략하는 등의 융통성 있는 개발이 가능하지만, 반면 제대로 이해하지 못 하고 사용한다면 절차적인 코드가 나올 수 밖에 없다. 흔히 가장 많이 하는 실수인 서비스 메소드를 c의 main 메소드 처럼 사용하는 것이다. 이런 경우 각 도메인 객체는 자료구조로 전락한다. 이 것이 문제다.
