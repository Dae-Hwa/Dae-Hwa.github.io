{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/2021-09-16--array-list/index.md/","result":{"data":{"site":{"siteMetadata":{"disqus":"gatsby-typescript"}},"post":{"html":"<p>List 인터페이스의 구현체 - 사이즈 변경가능한(resizable) array.\nList의 동작을 모두 구현, 모든 원소를 허가, null 포함하여. 내부적으로 목록을 저장하는데 사용되는 배열의 크기를 조작할 수 있다(동기화 되는 것을 제외하면 벡터와 거의 유사함).</p>\n<p><code class=\"language-text\">size</code>, <code class=\"language-text\">isEmpty</code>, <code class=\"language-text\">get</code>, <code class=\"language-text\">set</code>, <code class=\"language-text\">iterator</code>, and <code class=\"language-text\">listIterator</code>는 상수 시간으로 동작한다.\n<code class=\"language-text\">add</code>는 분할상환 상수 시간(amortized constant time)으로 동작한다. n개의 요소를 추가하는데 <code class=\"language-text\">O(n)</code>의 시간이 필요하다.</p>\n<blockquote>\n<p>분할상환 상수 시간?? 특정 상황에서는 시간이 더 필요하는데 나머지는 성능이 좋은 경우. 예를 들어 ArrayList같은 경우는 리밸런싱 전까지는 상수시간으로 add가 가능하지만, 이후에는 O(n)의 시간이 필요할 수 있음\n분할 상환 분석으로 알 수 있음\n<a href=\"https://codingdog.tistory.com/entry/amortized-%EB%B3%B5%EC%9E%A1%EB%8F%84-average-complexity%EC%99%80-%EB%AD%90%EA%B0%80-%EB%8B%A4%EB%A5%B8%EA%B0%80%EC%9A%94\">https://codingdog.tistory.com/entry/amortized-%EB%B3%B5%EC%9E%A1%EB%8F%84-average-complexity%EC%99%80-%EB%AD%90%EA%B0%80-%EB%8B%A4%EB%A5%B8%EA%B0%80%EC%9A%94</a>\n<a href=\"https://thebook.io/006950/ch15/01/05-03/\">https://thebook.io/006950/ch15/01/05-03/</a>\n<a href=\"https://kahee.github.io/algorithm_datastructure/2018/09/06/Alogrithm_book_ch4/\">https://kahee.github.io/algorithm_datastructure/2018/09/06/Alogrithm_book_ch4/</a>\n<a href=\"https://velog.io/@jeongpar/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B6%84%EC%84%9D2\">https://velog.io/@jeongpar/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B6%84%EC%84%9D2</a></p>\n</blockquote>\n<p>각 <code class=\"language-text\">ArrayList</code> 인스턴스는 capacity라는 것을 가진다. capacity는 리스트 내부에 요소(element)들을 저장하는데 쓰이는 배열의 크기이다. (당연하지만) 이는 항상 최소한 리스트의 사이즈 만큼 크다. 요소가 추가되면 capacity는 자동으로 증가한다. 증가하는 정책의 세부사항은 요소를 추가하는 것이 분할 상환 시간을 가진다는 것 외에는 정해져있지 않다.</p>\n<blockquote>\n<p>구현보면서 봐야할듯. O(n)의 시간만큼 수행하도록 증가한다?</p>\n</blockquote>\n<p>많은 양의 요소를 한꺼번에 넣기 전에 <code class=\"language-text\">ensureCapacity</code> 작업으로 capacity를 미리 키울 수 있다. 이는 증가하며 재할당되는 횟수를 줄여준다.</p>\n<p>동기화(synchronized)되어있지 않다. 많약 여러개의 스레드가 하나의 <code class=\"language-text\">ArrayList</code> 인스턴스에 동시에(concurrently) 접근하고, 적어도 하나의 스레드가 리스트를 구조적으로 변경한다면, 반드시 외부에서 동기화해줘야 한다.</p>\n<blockquote>\n<p>구조적 변경(structural modification)은 add, delete를 하거나 명시적으로 내부 배열(backing array)의 사이즈를 변경하는 경우를 말한다. 단순히 값을 변경하는 것은 구조적 변경이 아니다.</p>\n</blockquote>\n<p>이러한 동기화는 일반적으로 리스트를 캡슐화하는 객체에서 이뤄지지만, 그러한 객체가 없다면 Collections.synchronizedList 메소드로 리스트를 래핑해줘야 한다. 이는 객체 생성 시 해주는게 가장 좋다. 실수를 방지해준다.</p>\n<blockquote>\n<p>컬렉션을 필드로 가진 객체에서 동기화를 해줘야 한다는 것을 얘기하는듯.</p>\n</blockquote>","excerpt":"List 인터페이스의 구현체 - 사이즈 변경가능한(resizable) array.\nList의 동작을 모두 구현, 모든 원소를 허가, null…","timeToRead":2,"fields":{"slug":"/blog/2021-09-16--array-list/index.md/"},"frontmatter":{"tags":["java"],"author":{"id":"정대화","bio":"DaeHwa_Jeong@outlook.com"},"title":"ArrayList","updatedDate":"2021. 09. 16.","createdDate":"2021. 09. 16."}},"recents":{"edges":[{"node":{"fields":{"slug":"/blog/til/2021-11-08--til-20211108-13/"},"timeToRead":6,"frontmatter":{"tags":["til"],"title":"TIL-20211108~13","author":{"id":"정대화"}}}},{"node":{"fields":{"slug":"/blog/til/2021-10-31--til-20211031-1106/"},"timeToRead":4,"frontmatter":{"tags":["til"],"title":"TIL-20211031~1106","author":{"id":"정대화"}}}},{"node":{"fields":{"slug":"/blog/til/2021-10-28--til-20211027-30/"},"timeToRead":3,"frontmatter":{"tags":["til"],"title":"TIL-20211027~30","author":{"id":"정대화"}}}},{"node":{"fields":{"slug":"/blog/til/2021-10-12--til-20211010-23/"},"timeToRead":6,"frontmatter":{"tags":["til"],"title":"TIL-20211010~23","author":{"id":"정대화"}}}}]}},"pageContext":{"slug":"/blog/2021-09-16--array-list/index.md/","dateFormat":"YYYY. MM. DD."}},"staticQueryHashes":[]}