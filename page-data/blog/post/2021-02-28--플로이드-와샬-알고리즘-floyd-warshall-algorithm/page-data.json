{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/post/2021-02-28--플로이드-와샬-알고리즘-floyd-warshall-algorithm/","result":{"data":{"site":{"siteMetadata":{"disqus":"gatsby-typescript"}},"post":{"html":"<p>플로이드 알고리즘이라고도 많이 부른다. 모든 정점의 쌍에 대한 최단 경로의 길이를 알아야 하는 경우 사용된다. 즉 그래프에서 나올 수 있는 최단 경로를 모두 채워야 하는 경우이다.</p>\n<p>한 정점(vertex; 노드)에서 다른 정점으로 가는 최단거리의 합이 가장 적은 곳을 구하여 가장 좋은 입지를 구하는 데 사용할 수 있을 것이다. 또한, 두 개의 임의 지점에서 뭔가(패킷과 같은)를 전달할 때 걸리는 최대 시간을 구할 때 사용할 수도 있다. 또한, 가장 효과적인 출발지점을 찾기 위해 특정 정점에서 도착할 수 있는 모든 정점을 찾아내는 데 사용할 수도 있다.</p>\n<blockquote>\n<p>모든 정점에 대해 각 정점에서 갈 수 있는 정점의 갯수를 계산하는 것을 추이적 닫힘(transitive closure)이라고 한다.</p>\n</blockquote>\n<p>위에서 나온 예시들은 모든 정점에서 다익스트라 알고리즘을 각각 호출하여 풀이할 수도 있지만, 플로이드 와샬 알고리즘을 사용하면 매우 간단하게 풀이할 수 있다.</p>\n<p>모든 칸을 채우는 개념이기 때문에 인접 행렬(adjacency matrix)을 사용하는 것이 좋다. 표현하거나 생각하기도 쉽고, 어차피 모든 칸을 채워야 하기 때문에 공간이 낭비되는 것도 아니다. 아래는 플로이드 와샬의 결과로 나온 인접 행렬이다.\n| 1   | 2   | 3   | 4   | 5   |\n| --- | --- | --- | --- | --- |\n| 0   | 2   | 3   | 1   | 4   |\n| 12  | 0   | 15  | 2   | 5   |\n| 8   | 5   | 0   | 1   | 1   |\n| 10  | 7   | 13  | 0   | 3   |\n| 7   | 4   | 10  | 6   | 0   |</p>\n<p>row가 출발지고 column이 도착지다. 위의 그래프를 참고하여 1번에서 출발하여 4번에 도착하는 최소 거리는 1임을 알 수 있다.</p>\n<h2 id=\"구현\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%ED%98%84\" aria-label=\"구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구현</h2>\n<h3 id=\"초기화\" style=\"position:relative;\"><a href=\"#%EC%B4%88%EA%B8%B0%ED%99%94\" aria-label=\"초기화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>초기화</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> weight <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 최댓값으로 초기화</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i <span class=\"token operator\">!=</span> j <span class=\"token operator\">?</span> MAX <span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>인접 행렬로 가중치 그래프를 만든다. 정점 사이에 간선(edge)이 없는 경우(이동이 불가능한 경우)는 <code class=\"language-text\">MAX</code>로 초기화한다. 그래프의 지름이 초기화한 <code class=\"language-text\">MAX</code>보다 작을 경우 해당 부분은 무시된다. 예를 들어, int의 최댓값으로 초기화하면 가장 먼 거리(지름), 즉, 나올 수 있는 거리의 최댓값이 int의 최댓값 미만이어야 한다.</p>\n<blockquote>\n<p>그래프에서 가장 먼 두 정점 사이의 거리를 지름이라고 한다.\n<code class=\"language-text\">MAX</code>는 최댓값 + 1로 설정해야 한다. 최댓값과 똑같이 설정하면 간선이 있는 것으로 판단하게 된다.\nint를 사용할 경우 <code class=\"language-text\">Integer.MAX_VALUE/2</code> 이하의 값을 최댓값으로 사용할 수 있다. <code class=\"language-text\">k</code>를 거치는 경우 두 값을 더하기 때문에 int 최댓값을 사용하면 안 된다. <a href=\"#%EA%B7%B8%EB%9E%98%ED%94%84-%EC%99%84%EC%84%B1%ED%95%98%EA%B8%B0\">그래프 완성하기</a>를 보고 다시 보면 이해가 될 것이다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> edges <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// edges[n][0] 은 시작점, [1]은 도착점, [2]는 가중치라고 이며, 충분한 데이터가 들었다고 가정한다.</span>\n\n<span class=\"token comment\">// 가중치 옮기기</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> edges<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> edges<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> y <span class=\"token operator\">=</span> edges<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> curWeight <span class=\"token operator\">=</span> weight<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> newWeight <span class=\"token operator\">=</span> edges<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    \n    weight<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> newWeight <span class=\"token operator\">&lt;</span> curWeight <span class=\"token operator\">?</span> newWeight <span class=\"token operator\">:</span> curWeight<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>가중치 그래프가 만들어졌으면 가지고 있는 정점이나 간선의 정보를 토대로 가중치를 옮긴다. 이미 가중치 그래프가 있다면 생략한다.</p>\n<h3 id=\"그래프-완성하기\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9E%98%ED%94%84-%EC%99%84%EC%84%B1%ED%95%98%EA%B8%B0\" aria-label=\"그래프 완성하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그래프 완성하기</h3>\n<p>우선 n번만큼 반복한다. 0부터 n-1까지 증가하는 변수 <code class=\"language-text\">k</code>를 중간 정점의 후보로 사용한다. k 번째 반복일 경우 <code class=\"language-text\">k</code>를 지나가는 경로의 가중치 합과 기존에 계산해둔 가중치 중 큰 값을 선택한다.</p>\n<blockquote>\n<p><strong>예시</strong></p>\n<p>만약 <code class=\"language-text\">k</code>가 3이고 <code class=\"language-text\">i</code>와 <code class=\"language-text\">j</code>가 각각 1, 5일 경우, 정점3을 거쳐 가는 경로와 바로 가는 경로를 비교한다. 즉, <code class=\"language-text\">weight[1][3]</code>를 거쳐 <code class=\"language-text\">weight[3][5]</code>로 가는 경로의 가중치 합과 <code class=\"language-text\">weight[1][5]</code>의 가중치 합 중 작은 값을 선택한다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>weight<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> weight<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> weight<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                weight<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> weight<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> weight<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\">/* 위의 조건문은 아래와 같다\n             * weight[i][j] = Math.min(weight[i][k] + weight[k][j], weight[i][j]);\n             */</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>어떻게 두 개의 경로만 계속 비교하여 모든 그래프를 완성할 수 있는지 의문이 들 수 있는데, 위에서 들었던 예시에서 봤던 <code class=\"language-text\">k</code>가 3인 경우는 <code class=\"language-text\">k</code>가 1과 2였을 때, 그래프를 한 바퀴 순회하며 정점1과 정점2를 거쳐 가는 경우의 최솟값으로 채워져 있는 상태이다. 가령, <code class=\"language-text\">k</code>가 3이고 <code class=\"language-text\">i</code>가 5, <code class=\"language-text\">j</code>가 4인 경우, 정점5에서 정점3을 거쳐 정점4로 가는 경우를 확인한다. 이때, 정점5에서 정점3으로 가는 가중치의 합이 가장 낮은 경로가 정점5에서 정점1, 정점1에서 정점2를 거쳐 가는 것이라면 <code class=\"language-text\">k</code>가 1이었을 때, 그리고 2였을 때 이미 반영되어 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 507px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c1e995e38e551097d054e05b7876c08b/3ebb1/%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%99%80%EC%83%AC01.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.27167630057804%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACUElEQVQoz4VTaXPaMBD1//8pzUybmZZCiDnDYXMMlw0TzFkIvoiBAAEb26+rpSHtp+6MRtJb6Wm1+1ba79+wWCyg6zpc14FhjGh2MRwO4TguLpcLhMUxEIUhootPu0ggtyGwKIr4nHQ6nbDdbjGfz2HbFiaTKUxzhdVqhbPvIySSK2HM8+W4xUDroakqaDdrqClVIDyzL6IzkrfZoNFoENGEAWHn8xk9utRut24RChsZQ6ilPJazCTzbxGHnQeu0CCvApAA4wlQqxdGVy2X67jODSrUCTdPQ6/WgKgpjfV2DQusxPVwsPlGo79i4FkqlEmZ0P5vNwbJMSMlkki+YpoVaNUsrD5n0/e2befmBvnRE4eE7RL6FlUtFvL+u0FUKGI8MxgzDQCaTgZTL5VCv13mzXL6ws9vVOIpC4Qk9fcDYcmVBzuRQUeuoVFXGTv6FIsujUVchyzKnShIO8bX1ev0nU9dqvbkaDmuNVntEZ5vC3RJm4KWRAIL1dYQbBIcFzKkC37/mmgl3ux3LIvQ9SrgOvVuDoZeoko+YjVpEdiC/qHZA/DbiKKBBUglJQvFn0eI4uhI6joMgIEfs47j34NpLuI4Jy1zAe7X5sO8HpLUY/zMm9DyPK2TbDhfHNG1+RAhbiNxx13hMp0lGbRa/aITxeMwz+/nsdUiikh+i/TWfUnFkfP12jypJJJH4wbLI5fNoklbvvtzhJ6miVlMh1PFM3cRZpy754JH+7gLLsjDo96kNNWh6nwRfR6vdQYcim05nGAwGpNcK6/Yzb/+m4TcgGXhAH1cO2QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"플루이드와샬 설명\"\n        title=\"플루이드와샬 설명\"\n        src=\"/static/c1e995e38e551097d054e05b7876c08b/3ebb1/%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%99%80%EC%83%AC01.png\"\n        srcset=\"/static/c1e995e38e551097d054e05b7876c08b/991de/%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%99%80%EC%83%AC01.png 173w,\n/static/c1e995e38e551097d054e05b7876c08b/e4d6b/%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%99%80%EC%83%AC01.png 345w,\n/static/c1e995e38e551097d054e05b7876c08b/3ebb1/%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%99%80%EC%83%AC01.png 507w\"\n        sizes=\"(max-width: 507px) 100vw, 507px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>간단히 정리해보면, A에서 B까지의 가장 빠른 경로는 A에서 B로 바로 가는 것 혹은 A에서 k로 가는 가장 빠른 경로와 k에서 B로 가는 가장 빠른 경로를 합친 것이다. 반대로 말하면 A에서 B로 가는 경로보다 빠른, 정점 <code class=\"language-text\">k</code>를 지나는 경로가 있어야 경로가 달라진다.</p>\n<p>어려운 문제를 간단하게 나누어 풀기 때문에 동적 프로그래밍(dynamic programming)으로 분류되기도 한다. 그리디(greedy)라 생각할 수도 있는데 각 정점에서 가장 빠른 경로를 찾는 것이 아니라, 전체를 고려하여 최적의 경로를 찾아내는 것이기 때문에 그리디가 아닌 동적 프로그래밍이다.</p>\n<h2 id=\"다익스트라-알고리즘dijkstra-algorithm과-비교\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98dijkstra-algorithm%EA%B3%BC-%EB%B9%84%EA%B5%90\" aria-label=\"다익스트라 알고리즘dijkstra algorithm과 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%81%AC%EC%8A%A4%ED%8A%B8%EB%9D%BC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">다익스트라 알고리즘(Dijkstra Algorithm)</a>과 비교</h2>\n<p>다익스트라 알고리즘 또한 가중치가 있는 그래프에서 최단 거리를 구하는 알고리즘이다. 다익스트라 알고리즘은 모든 간선의 최단 거리가 아닌 한 정점에서 도착점까지의 최단 거리를 구한다. 해당 경우는 다익스트라 알고리즘이 빠르지만, 앞서 말했듯, 한 정점에서 특정 도착점까지의 최단 거리를 구하는 것이다. 따라서 플로이드 와샬을 사용할 때처럼 모든 경로를 채워야 한다면, 각 정점에서 다익스트라를 계속해서 실행해야 하므로 해당 경우는 플로이드 와샬이 효과적이다.</p>\n<p>또한, 다익스트라 알고리즘은 그리디 기반이기 때문에 음의 가중치가 있는 그래프의 경우는 판단하지 못한다. 반면, 플로이드 와샬은 음의 가중치가 있는 그래프에서도 사용 가능하며, 음수 사이클도 판단할 수 있다. 음의 사이클이 생기면 <code class=\"language-text\">i==j</code>의 경로가 변하기 때문에 해당 결과가 나오면 음의 사이클이라 판단할 수 있다.</p>\n<hr>\n<h2 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References</h2>\n<ul>\n<li><a href=\"https://ko.wikipedia.org/wiki/%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%9B%8C%EC%85%9C_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">플로이드-워셜 알고리즘</a></li>\n<li><a href=\"https://www.hanbit.co.kr/store/books/look.php?p_code=B5937184860\">Programming Challenges: 알고리즘 트레이닝 북</a></li>\n</ul>","excerpt":"플로이드 알고리즘이라고도 많이 부른다. 모든 정점의 쌍에 대한 최단 경로의 길이를 알아야 하는 경우 사용된다. 즉 그래프에서 나올 수 있는 최단 경로를 모두 채워야 하는 경우이다. 한 정점(vertex…","timeToRead":5,"fields":{"slug":"/blog/post/2021-02-28--플로이드-와샬-알고리즘-floyd-warshall-algorithm/"},"frontmatter":{"tags":["알고리즘"],"author":{"id":"정대화","bio":"DaeHwa_Jeong@outlook.com"},"title":"플로이드 와샬 알고리즘(Floyd Warshall Algorithm)","updatedDate":"2021. 02. 28.","createdDate":"2021. 02. 28."}},"recents":{"edges":[{"node":{"fields":{"slug":"/blog/til/2021-12-07--til-20211205-11/"},"timeToRead":5,"frontmatter":{"tags":["til"],"title":"TIL-20211205~11","author":{"id":"정대화"}}}},{"node":{"fields":{"slug":"/blog/til/2021-12-01--til-20211130-1204/"},"timeToRead":3,"frontmatter":{"tags":["til"],"title":"TIL-20211130~1204","author":{"id":"정대화"}}}},{"node":{"fields":{"slug":"/blog/til/2021-11-17--til-20211116-19/"},"timeToRead":2,"frontmatter":{"tags":["til"],"title":"TIL-20211116~19","author":{"id":"정대화"}}}},{"node":{"fields":{"slug":"/blog/til/2021-11-08--til-20211108-13/"},"timeToRead":6,"frontmatter":{"tags":["til"],"title":"TIL-20211108~13","author":{"id":"정대화"}}}}]}},"pageContext":{"slug":"/blog/post/2021-02-28--플로이드-와샬-알고리즘-floyd-warshall-algorithm/","dateFormat":"YYYY. MM. DD."}},"staticQueryHashes":[]}